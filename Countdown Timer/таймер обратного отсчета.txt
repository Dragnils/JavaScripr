Я думаю, что это делает для проблем с производительностью, а также делает вашу прокрутку красивой и гладкой. Подобно тому, как, если вы прокрутите страницу, 
ваши анимированные гифки также остановятся. Так что это не очень хороший вариант использования, потому что если бы я прокручивал в течение 10 секунд, то это
 добавило бы дополнительные 10 секунд к перерыву. Поэтому вместо того, чтобы делать это, мы будем использовать интервал, но по-другому. То, что мы хотим сделать,
 это выяснить, когда таймер запустился, просто const теперь равен date.now. Это своего рода новый браузер. Раньше нам приходилось делать как, новую дату, а затем
 получать время, но теперь вызывается новый статический метод для даты, который просто даст нам текущую метку времени в миллисекундах. Тогда мы также хотим «затем»,
 которое теперь равно числу секунд, для которого вы хотите запустить таймер, но сейчас оно будет в миллисекундах, а секунды, очевидно, в секундах. Таким образом, мы
 просто умножаем это на 1000. Так что это консольный журнал, время от времени, чтобы посмотреть, что у нас здесь происходит. Если бы мне пришлось обновить это,
 запустите таймер 10, вы увидите наши значения «сейчас» и «тогда», которые мы имеем здесь. Хорошо, так что те работают на нас. Следующее, что нам нужно сделать,
 это каждую секунду, нам нужно отобразить оставшееся время. Здесь мы устанавливаем интервал. Здесь можно использовать интервал, потому что мы действительно не беспокоимся
 о том, что он запускается каждую секунду, если что-то случится. Но, скажем так, мы пропустили две секунды. Он просто обновится через две секунды и покажет нам эти две секунды
 меньше, чем одну. Итак, здесь можно использовать его, мы будем запускать его каждую секунду, что составляет 1000 миллисекунд. Тогда нам нужно выяснить, сколько времени осталось
 на часах. Мы возьмем наше тогда, то есть когда оно остановится, мы скажем, что const секунд осталось равным тогда минус, и мы не можем просто сказать сейчас, потому что это было
 захвачено, когда он работал, но нам нужно запустить date.now один раз Больше. Опять же, теперь это будет в миллисекундах, поэтому мы хотим разделить это на 1000, чтобы мы могли
 получить секунды. Журнал консоли осталось секунд. Посмотрим, что у нас здесь. Восемь с половиной, семь, шесть, пять, поэтому у нас есть небольшая ошибка округления. О, это немного странно.
 Я думаю, только потому, что мы имеем дело с миллисекундами и делаем это деление здесь, так что вы можете обернуть все это в math.round. Затем запустите его в десять, девять, вот и мы.
 Возможно, вы только что видели, что это начало становиться отрицательным через некоторое время. И почему так? Потому что интервалы не знают, когда остановиться. Итак, что нам нужно сделать,
 прежде чем мы отобразим это, мы должны проверить, должны ли мы остановить это. Как вы остановились? Я скажу, что если оставшиеся секунды меньше или равны нулю, мы хотим остановить это.
 Итак, очевидно, мы могли бы вернуть, что остановит выполнение функции, но это не поможет нам, и я покажу вам здесь. Это не остановит этот интервал, он просто запустится, но не покажет нам ничего.
 Что нам нужно сделать, это сохранить этот интервал в своей собственной переменной. Я собираюсь подняться сюда и сказать «пусть обратный отсчет», и это будет наша переменная более высокого уровня.
 В данном случае это глобальная переменная, она будет жить в окне, но вы можете вставить ее в IFFE, а не в глобальное пространство имен. Тогда здесь мы собираемся просто обновить его. Обратный отсчет равен.
 Тогда здесь мы назовем clear interval и передадим ему имя нашего таймера, которое является обратным отсчетом. Затем, когда мы запустим его, давайте запустим его с тремя секундами слева, двумя, одним,
 и тогда он никогда не запустится снова, потому что мы нажали это здесь. Очень быстро в стороне, извините, что я должен прыгнуть сюда, хотя я сказал меньше или равно, но это заканчивается тем, что
 оставляет нам одну секунду. Очевидно, что мы хотим меньше нуля секунд, что даст нам два, один и ноль. Не меньше или равно, просто меньше. Хорошо, вернемся к запланированному программированию.
 Теперь, еще одна проблема, с которой мы сталкиваемся, - если я бегу 10 секунд, посмотрим, что произойдет. Только через одну секунду он действительно запускается. Проблема в том, что установленный интервал,
 который мы имеем здесь, не запускается сразу. Он должен ждать, пока пройдет первая секунда.
Итак, что я хочу сделать, мы создадим здесь вторую функцию, которая называется оставшееся время отображения, которое занимает несколько секунд. Здесь мы собираемся в консоль записать количество оставшихся секунд,
 и мы собираемся изменить это на минуты и еще много чего. Здесь, вместо того, чтобы консоль регистрировать это, мы собираемся показать это, что он должен делать то же самое, все еще через секунду. Но тогда мы также
 можем запустить это, как только функция будет вызвана. Мы запустим оставшееся время отображения и передадим его секундами. Мы собираемся запустить его сразу один раз, а затем еще раз, каждый раз, когда мы делаем 
этот интервал. Здесь мы идем, таймер. Увидеть? Он сразу делает 10, а затем мы будем считать с 9 до 6, вплоть до 1. Хорошо, так что эта небольшая функция обратного отсчета, которую мы здесь написали, выглядит довольно
 хорошо, теперь я хочу перейти к нашему времени отображения осталось и начать работать с преобразованием его в минуты и секунды. В предыдущем видео мы взяли все наши секунды и конвертировали

Мы будем делать здесь только минуты и секунды, но вы также можете делать это часами. Поэтому я скажу, что постоянные минуты равны секундам, разделенным на 60, и давайте просто

Поэтому я говорю const remainderSeconds, и это будет секунд 60 мод, и мод даст нам остаток, который у нас есть. Минуты и оставшиеся секунды, таймер, пошли, три, два, один. Это снижается до 1 минуты и 59 секунд.
 Хорошо. Итак, у нас есть наши минуты в наших оставшихся секундах, теперь мы можем начать
У нас осталось время показа здесь. Если бы мы поместили это в переменную, отображение таймера const будет равно document.querySelector. Мы хотим посмотреть на это. Затем мы спустимся сюда и создадим другую переменную,
 которая будет нашим временем отображения, которая будет выглядеть примерно как 11:11, верно? Как мы получаем количество оставшихся минут? Просто минуты: количество оставшихся секунд. Затем мы берем наш timerDisplay,
 который является нашим div, мы устанавливаем textContent для отображения. Мы можем избавиться от этого журнала консоли, потому что теперь мы имеем дело с реальным. Теперь мы запускаем это. О, хорошо, вроде работает,
 но ты видишь, в чем здесь проблема? Когда у вас осталось менее 10 секунд, он просто говорит 4 секунды, но у нас должно быть 04 секунды. Как мы это делаем? Ну, мы могли бы перейти к этому remainderSeconds, и мы скажем,
 если remainderSeconds больше 10 или, извините, меньше 10, тогда мы хотим вернуть ноль. Это вопросительный знак, это сокращенный троичный оператор, и в противном случае мы просто не собираемся ничего возвращать. 
И это даст нам ноль. И, наконец, в конце здесь, вы можете просто дать нам оставшиеся секунды. Так что, если мы запустим его сейчас, со 124 секундами, у нас будет этот добавленный ноль на фронте, пока он не достигнет этого.
 Другое дело, что мы должны обновить вкладку нашего браузера здесь, она просто говорит таймер обратного отсчета. Мы можем просто сказать document.title. Document.title - это тег заголовка в вашем HTML, равнозначный отображению.
 Теперь мы собираемся запустить его. Вот так. Это обновляет это, поскольку мы обновляем это. Вы можете поместить это действительно там, где это вам нравится.
Теперь я хочу работать над той другой функцией, которая показывает время окончания. Если сейчас 2:30, а у вас пятиминутный перерыв, я хочу вернуться в 2:35. Мы создадим функцию с именем displayEndTime. Это займет время, когда вы 
хотите закончить. Это наше время здесь. Берет временную метку, и мы должны превратить ее в дату. Конец конца равен новой дате. Вы хотите передать ему метку времени. Зачем? Если вы никогда раньше не работали с метками времени, это то,
 как они работают. У вас есть date.now, который составляет всего несколько миллисекунд с 1 января 1970 года. Именно тогда Бог сотворил землю. Это количество миллисекунд, прошедших с того времени. Теперь, если бы вы просто взяли это,
 затем поместили в строку и затем вернулись в JavaScript, вы бы сказали: «Хорошо, мне нужно преобразовать это обратно в дату». Вы говорите новую дату и передаете количество миллисекунд, которое у вас есть. Это собирается преобразовать
 это. Сейчас 1 декабря, конвертируйте его в правильную временную метку для вас. Что здорово в этом, вы можете поместить его в переменную с именем X, а затем вызвать X.getDate, X.getDay, X.getMonth, и вы получите всю информацию о том,
 какой день и месяц и все такое. Это правильная дата. Это требует отметки времени. Мы создаем новый объект даты из этого. Тогда мы можем просто получить часы. Мы скажем, что const hour равно end.getHours, а const minutes равно
 end.getMinutes, тогда мы скажем конечное время, которого у нас пока нет. Давайте вернемся к вершине здесь. Каково наше время окончания? Время окончания отображения. Возьмите эту присоску, const endTime равен document.querySelector.
 Мы возьмем эту вещь с классом отображения, конечным временем. Итак, мы получили этот endTime.textContent равным, и я просто собираюсь установить его здесь. Ранее мы помещали его в переменную с именем display. Зачем?
 Потому что мне нужно было использовать его не раз. Мне нужно было использовать его для обновления заголовка, а также для обновления текстового содержимого. Но в этом случае я просто хочу сделать это прямо здесь.
 Мы скажем «Be Back At», а затем мы возьмем час, и мы возьмем минуты. Это легко, правда? Нет, это будет не так просто, но давайте попробуем. В нашем таймере мы не собираемся запускать это в нашем интервале, его не нужно
 обновлять каждую секунду, это просто должно происходить один раз, когда вы запускаете таймер. Итак, просто просто отобразите EndTime, затем передайте его, который является конечным временем. Так что, если бы я запустил наш таймер с,
 я не знаю, 3000 секунд, чтобы передать его в него, у нас осталось 50 минут. Но проблема в том, что я не европеец, и я не понимаю, что такое 15:00. Я знаю, что должен вернуться в 3:11. Так что нам нужно, иди сюда, и если ты европеец,
 поздравляю. Вы можете оставить эту часть и, возможно, пойти получить поп или что-то в этом роде. Но мы, канадцы и американцы, и кто бы ни был нормальным, должны войти в этот час, и мы скажем, что если час больше 12, то нам нужно
 вернуть час минус 12, в противном случае мы хотим просто вернуть час. И если это немного слишком для вас, вы можете просто зайти сюда и создать новую переменную const, значение которой равно часу, мы вернем час минус 12. Так что,
 если это 13:00, возьмите прочь 12, это 1:00 и возьми этот скорректированный час и положи его сюда, так как это выглядит? Хорошо, вернись в 3:12, хорошо. Итак, у нас работает таймер, работает наша функция, она обновляет, отображает
 и все остальное.